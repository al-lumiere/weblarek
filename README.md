# Проектная работа "Веб-ларек"
https://github.com/al-lumiere/weblarek.git

Стек: HTML, SCSS, TS, Webpack

Структура проекта:
- src/ — исходные файлы проекта
- src/components/ — папка с JS компонентами
- src/components/base/ — папка с базовым кодом

Важные файлы:
- index.html — HTML-файл главной страницы
- src/types/index.ts — файл с типами
- src/main.ts — точка входа приложения
- src/scss/styles.scss — корневой файл стилей
- src/utils/constants.ts — файл с константами
- src/utils/utils.ts — файл с утилитами

## Установка и запуск
Для установки и запуска проекта необходимо выполнить команды

```
npm install
npm run start
```

или

```
yarn
yarn start
```
## Сборка

```
npm run build
```

или

```
yarn build
```
# Интернет-магазин «Web-Larёk»
«Web-Larёk» — это интернет-магазин с товарами для веб-разработчиков, где пользователи могут просматривать товары, добавлять их в корзину и оформлять заказы. Сайт предоставляет удобный интерфейс с модальными окнами для просмотра деталей товаров, управления корзиной и выбора способа оплаты, обеспечивая полный цикл покупки с отправкой заказов на сервер.

## Архитектура приложения

Код приложения разделен на слои согласно парадигме MVP (Model-View-Presenter), которая обеспечивает четкое разделение ответственности между классами слоев Model и View. Каждый слой несет свой смысл и ответственность:

Model - слой данных, отвечает за хранение и изменение данных.
View - слой представления, отвечает за отображение данных на странице.
Presenter - презентер содержит основную логику приложения и  отвечает за связь представления и данных.

Взаимодействие между классами обеспечивается использованием событийно-ориентированного подхода. Модели и Представления генерируют события при изменении данных или взаимодействии пользователя с приложением, а Презентер обрабатывает эти события используя методы как Моделей, так и Представлений.

### Базовый код

#### Класс Component
Является базовым классом для всех компонентов интерфейса.
Класс является дженериком и принимает в переменной `T` тип данных, которые могут быть переданы в метод `render` для отображения.

Конструктор:
`constructor(container: HTMLElement)` - принимает ссылку на DOM элемент за отображение, которого он отвечает.

Поля класса:
`container: HTMLElement` - поле для хранения корневого DOM элемента компонента.

Методы класса:
`render(data?: Partial<T>): HTMLElement` - Главный метод класса. Он принимает данные, которые необходимо отобразить в интерфейсе, записывает эти данные в поля класса и возвращает ссылку на DOM-элемент. Предполагается, что в классах, которые будут наследоваться от `Component` будут реализованы сеттеры для полей с данными, которые будут вызываться в момент вызова `render` и записывать данные в необходимые DOM элементы.
`setImage(element: HTMLImageElement, src: string, alt?: string): void` - утилитарный метод для модификации DOM-элементов `<img>`


#### Класс Api
Содержит в себе базовую логику отправки запросов.

Конструктор:
`constructor(baseUrl: string, options: RequestInit = {})` - В конструктор передается базовый адрес сервера и опциональный объект с заголовками запросов.

Поля класса:
`baseUrl: string` - базовый адрес сервера
`options: RequestInit` - объект с заголовками, которые будут использованы для запросов.

Методы:
`get(uri: string): Promise<object>` - выполняет GET запрос на переданный в параметрах ендпоинт и возвращает промис с объектом, которым ответил сервер
`post(uri: string, data: object, method: ApiPostMethods = 'POST'): Promise<object>` - принимает объект с данными, которые будут переданы в JSON в теле запроса, и отправляет эти данные на ендпоинт переданный как параметр при вызове метода. По умолчанию выполняется `POST` запрос, но метод запроса может быть переопределен заданием третьего параметра при вызове.
`handleResponse(response: Response): Promise<object>` - защищенный метод проверяющий ответ сервера на корректность и возвращающий объект с данными полученный от сервера или отклоненный промис, в случае некорректных данных.

#### Класс EventEmitter
Брокер событий реализует паттерн "Наблюдатель", позволяющий отправлять события и подписываться на события, происходящие в системе. Класс используется для связи слоя данных и представления.

Конструктор класса не принимает параметров.

Поля класса:
`_events: Map<string | RegExp, Set<Function>>)` -  хранит коллекцию подписок на события. Ключи коллекции - названия событий или регулярное выражение, значения - коллекция функций обработчиков, которые будут вызваны при срабатывании события.

Методы класса:
`on<T extends object>(event: EventName, callback: (data: T) => void): void` - подписка на событие, принимает название события и функцию обработчик.
`emit<T extends object>(event: string, data?: T): void` - инициализация события. При вызове события в метод передается название события и объект с данными, который будет использован как аргумент для вызова обработчика.
`trigger<T extends object>(event: string, context?: Partial<T>): (data: T) => void` - возвращает функцию, при вызове которой инициализируется требуемое в параметрах событие с передачей в него данных из второго параметра.

#### Данные
В приложении используются два интерфейса — товар и покупатель.

`IItem` - описывает свойства товара, в которые входит: {
  id: string;
  title: string;
  category: string;
  image: string;
  price: number || null;    // null = "бесценно"
  description: string;
  }

`ICustomer` - описывает свойства покупателя, в которые входит: {
  payment: TPayment;     // “Онлайн” || “При получении” || null
  address: string;
  email: string;
  phone: string;
}

В приложении используются три класса — каталог товаров, корзина и покупатель.

`Products` — хранит товары, которые можно купить в приложении. Принимает параметры из интерфейса `IItem`.

Конструктор:
`constructor(items: IItem[] = [], currentItem: IItem | null = null)` — массив товаров для каталога.

Его свойства:
`allItems: IItem[]` — массив всех товаров, что есть в магазине;
`currentItem: IItem | null` — выбранная для подробного рассмотрения карточка.

Его методы:
`setItems(items: IItem[]): void` – сохранение массива товаров;
`getItems(): IItem[]` – получение массива товаров;
`getItemById(id: string): IItem | undefined` — получение одного товара по его id;
`setCurrentItem(item: IItem): void` — сохранение товара для подробного отображения;
`getCurrentItem(): IItem | null` — получение товара для подробного отображения.

`Basket` — хранит товары, которые пользователь выбрал для покупки.

Конструктор:
`constructor(items: IItem[] = [])` — корзина создается пустой.

Ее свойства:
`selectedItems: IItem[]` — массив всех товаров, что были выбраны;

Ее методы:
`getBItems(): IItem[]` – получение массива товаров, которые находятся в корзине;
`addBItem(item: IItem): void` – добавление товара, который был получен в параметре в массив корзины;
`removeBItem(item: IItem): void`– удаление товара, полученного в параметре из массива корзины;
`clearBasket(): void`— очистка корзины;
`getBTotalPrice(): number`– получение стоимости всех товаров в корзине;
`getBCount(): number`— получение количества товаров в корзине;
`busketHasItem(id: string): boolean`— проверка наличия товара в корзине по его id, полученного в параметр метода.

`CustomerInfo` — хранит и  обрабатывает данные покупателя, которые тот должен указать при оформлении заказа. Принимает параметры из интерфейса `ICustomer`.

Конструктор:
`constructor (customer: ICustomer = { payment: null, email: "", phone: "", address: "" })` — данные покупателя.

Ее свойства:
`payment: TPayment` — способ оплаты;
`address: string` — адрес покупателя;
`email: string` — почта покупателя;
`phone: string` — телефон покупателя;

Ее методы:
`setCData(data: ICustomer): void`— сохранение данных в модели;
`setField<T extends keyof ICustomer>(key: T, value: ICustomer[T]): void` — сохранение данных одного конкретного поля;
`getCData(): ICustomer`– получение всех данных покупателя;
`getField<T extends keyof ICustomer>(key: T): ICustomer[T]` – получение данных одного конкретного поля;
`clearCustomerInfo(): void`– очистка данных покупателя;
`validateField<T extends keyof ICustomer>(key: T): boolean` — валидация одного поля;
`validateCustomer(): boolean` — валидация всех данных.

#### Слои коммуникации
`Server` – класс, который отвечает за получение данных с API «веб-ларёк» и отправку данных обратно. Использует композицию: в конструктор передаётся объект, реализующий интерфейс IApi.

Конструктор:
`constructor(api: IApi)` — клиент HTTP-запросов низкого уровня.

Методы:
`getProducts(): Promise<IItem[]>` – GET /product/, возвращает массив товаров.
`createOrder(payload: OrderRequest): Promise<OrderResponse>` – POST /order/, отправляет данные покупателя и список id выбранных товаров.

Типы данных, необходимые для обмена:
`ApiProductsResponse = { total: number; items: IItem[]}` – ответ /product/.
`OrderRequest: ICustomer & { items: string[]}`– данные заказа ( CustomerInfo + список id товаров).
`OrderResponse: { orderId: string; total: number}` – ответ на создание заказа.

#### Слой отображения данных
Используемые интерфесы:

`IHeader` - количество товаров в корзине {
  count: number;
}

`IGallery` – список товаров, который будет отображаться в галлерее {
  catalogItems: HTMLElement[];
}

`IModalWindow` — контент для отображения в модальных окнах {
  content: HTMLElement;
  opened: boolean;
}

`IBasketView` – список товаров в корзине и их общая стоимость {
  basketContent: HTMLElement[];
  basketPrice: number;
  disabled: boolean;
}

`ISuccessedOrder` — количество списанных синапсов {
  price: number;
}

`IFormBase` — ошибки в заполнении формы, состояние кнопки {
  error?: string;
  disabled?: boolean;
}

`IOrderForm extends IFormBase` — данные по оплате и адрессу {
  address?: string;
  payment?: TPayment;
}

`IContactForm extends IFormBase` — данные по оплате и адрессу {
  email?: string;
  phone?: string;
}

`ICardBase` – данные карточки (название и цена) {
  title: string;
  price: number | null;
}

`ICatalogCard extends ICardBase` – данные карточки (картинка и категория) {
  image: string;
  category: string;
}

`IPreviewCard extends ICardBase` – данные карточки (названиеб картинкаб категория и цена) {
  image: string;
  category: string;
  text: string;
  buttonText: string;
  disabled: boolean;
}

`IBasketCard extends ICardBase` – данные карточки (индекс в корзине) {
  index: string;
}

Все классы в слое отображения строятся на основе класса Component.

`Header` — класс, который отвечает за открытие корзины и счетчик кол-ва элементов в ней. В классе два свойства — basket и basketCounter. Принимает параметры из интерфейса `IHeader`.

Конструктор:
`constructor(protected events: IEvents, container: HTMLElement)` — наследуем контейнер, находим HTML-элементы и обрабатываем событие клика.

Его свойства:
`protected basket: HTMLButtonElement` – кнопка для открытия корзины.
`protected basketCounter: HTMLElement` – счетчик количества элементов в корзине.

Его методы:
`set count (value: number)` – отображает значение счетчика количества элементов в корзине.

`Gallery` — класс, отображение каталога карточек товаров. В классе одно свойство catalog. Принимает параметры из интерфейса `IGallery`.

Конструктор:
`constructor(container: HTMLElement)` — наследуем контейнер, находим HTML-элементы.

Его свойства:
`protected catalog: HTMLElement` – галлерея.

Его методы:
`set catalogItems (items: HTMLElement [])` – отображает каталог товаров в галлерее.

`ModalWindow` — класс, который используется для отображения контента в модальных окнах. В классе два свойства — modalContent и closeButton.Принимает параметры из интерфейса `IModalWindow`.

Конструктор:
`constructor(protected events: IEvents, container: HTMLElement)` — наследуем контейнер, находим HTML-элементы и обрабатываем событие клика.

Его свойства:
`protected modalContent: HTMLElement` –  элемент для отображения контента.
`protected closeButton: HTMLButtonElement` – кнопка для закрытия модального окна.

Его методы:
`set content (item: HTMLElement)` – отображает контент в модальном окне.
`set opened(value: boolean | undefined)` — отображает модальное окно.

`BasketView` — класс, который используется для отображения содержимого корзины, стоимости товаров в ней и кнопки для оформления заказа. В классе три свойства — itemsList, orderButton и itemsPrice. Принимает параметры из интерфейса `IBasketView`.

Конструктор:
`constructor(protected events: IEvents, container: HTMLElement)` — наследуем контейнер, находим HTML-элементы и обрабатываем событие клика.

Ее свойства:
`protected itemsList: HTMLElement` – элемент для отображения содержимого корзины.
`protected itemsPrice: HTMLElement` – счетчик общей стоимости товаров в корзине.
`protected orderButton: HTMLButtonElement` – кнопка для оформления заказа.

Ее методы:
`set basketContent(items: HTMLElement [])` – отображает элементы в модальном окне корзины.
`set basketPrice(value: number)` – отображает общую стоимость товаров в корзине.
`set disabled(value: boolean | undefined)` — отображает возможность офомления заказа (если в корзине товаров нет, то и заказ сделать нельзя).

`SuccessedOrder` — класс, который используется для сообщения об успешности оформления заказа. В классе два свойства — closeButton и finalPrice. Принимает параметры из интерфейса `ISuccessedOrder`.

Конструктор:
`constructor(protected events: IEvents, container: HTMLElement)` — наследуем контейнер, находим HTML-элементы и обрабатываем событие клика.

Его свойства:
`protected closeButton: HTMLButtonElement` — кнопка для перехода к новым покупкам.
`protected finalPrice: HTMLElement` — элемент для отображения количества списанных синапсов.

Его методы:
`set price(value: number)` — отображает количество списанных синапсов.

`FormBase` — базовый класс для отображения форм. На его основе будет создан класс `OrderForm` для данных о способе оплаты и адресе доставки, а так же класс `ContactForm` для контактных данных. В классе два свойства — submitButton и errorForm.  Принимает параметры из интерфейса `IFormBase`.

Конструктор:
`constructor(protected events: IEvents, container: HTMLElement)` — наследуем контейнер, находим HTML-элементы и обрабатываем событие.

Его свойства:
`protected submitButton: HTMLButtonElement` — кнопка для подтверждения информации.
`protected errorForm: HTMLElement` — элемент для вывода ошибок.

Его методы:
`set error(value: string)` — отображает ошибки в заполнении формы, если таковые имеются.
`set disabled(value: boolean | undefined)` — отображает состояние кнопки.

`OrderForm` — дочерний класс `FormBase`, использующийся непосредственно для сбора данных о способе оплаты и адресе доставки. В нем три свойства — cashButton, cardButton и addressInput. Принимает параметры из интерфейса `IOrderForm`.

Конструктор:
`constructor(protected events: IEvents, container: HTMLElement)` — наследуем контейнер, находим HTML-элементы и обрабатываем событие.

Его свойства:
`protected cashButton: HTMLButtonElement` — кнопка оплаты наличными.
`protected cardButton: HTMLButtonElement` — кнопка оплаты картой.
`protected addressInput: HTMLInputElement` — элемент для ввода адреса.

Его методы:
`set address (value: string | undefined)` — отображает введенный адрес.
`set payment(value: TPayment)` — отображает выбранный способ оплаты.

`ContactForm` — дочерний класс `FormBase`, использующийся непосредственно для сбора данных почты и номера телефона. В нем два свойства —  emailInput и phoneInput. Принимает параметры из интерфейса `IContactForm`.

Конструктор:
`constructor(protected events: IEvents, container: HTMLElement)` — наследуем контейнер, находим HTML-элементы и обрабатываем событие.

Его свойства:
`protected emailInput: HTMLInputElement` — элемент для ввода почты.
`protected phoneInput: HTMLInputElement` — элемент для ввода телефона.

Его методы:
`set email (value: string | undefined)` — отображает введенную почту.
`set phone (value: string | undefined)` — отображает введеный номер телефона.

`CardBase` — базовый класс для отображения форм. На его основе будет создан класс `CatalogCard` для отображения карточек в галлерее, `PreviewCard` для отображения карточки в модальном окне и `BasketCard` для отображения карточки в корзине. В классе два свойства — cardTitle и cardPrice. Принимает параметры из интерфейса `ICardBase`.

Конструктор:
`constructor(container: HTMLElement)` — наследуем контейнер, находим HTML-элементы.

Его свойства:
`protected cardTitle: HTMLElement` — название товара.
`protected cardPrice: HTMLElement` — цена товара.

Его методы:
`set title(value: string)` — отображает название товара.
`set price(value: number | null)` — отображает стоимость товара.

`CatalogCard` — дочерний класс `CardBase`, использующийся для отображения карточек в галлерее. В нем два свойства —  cardCategory и cardImage. Принимает параметры из интерфейса `ICatalogCard`.

Конструктор:
`constructor(protected events: IEvents, container: HTMLElement)` — наследуем контейнер, находим HTML-элементы и обрабатываем событие.

Его свойства:
`protected cardCategory: HTMLElement` — категория товара.
`protected cardImage: HTMLImageElement` — картинка товара.

Его методы:
`set image (value: string)` — отображает кантинку товара.
`set category (value: string)` — отображает категорию товара.

`PreviewCard` — дочерний класс `CardBase`, использующийся для отображения карточек в модальном окне. В нем четыре свойства —  cardCategory, cardImage, cardText и cardButton. Принимает параметры из интерфейса `IPreviewCard`.

Конструктор:
`constructor(protected events: IEvents, container: HTMLElement)` — наследуем контейнер, находим HTML-элементы и обрабатываем событие.

Его свойства:
`protected cardCategory: HTMLElement` — категория товара.
`protected cardImage: HTMLImageElement` — картинка товара.
`protected cardText: HTMLElement` – описание товара.
`protected cardButton: HTMLButtonElement` – кнопка для добавления товара в корзину.

Его методы:
`set image (value: string)` — отображает кантинку товара.
`set category (value: string)` — отображает категорию товара.
`set text (value: string)` – отображает описание товара.
`set buttonText(value: string)` — отображает текст кнопки.
`set disabled(value: boolean)` – отображает активна ли кнопка.

`BasketCard` — дочерний класс `CardBase`, использующийся для отображения карточек в корзине. В нем два свойства — itemBasketIndex и deleteButton. Принимает параметры из интерфейса `IBasketCard`.

Конструктор:
`constructor(protected events: IEvents, container: HTMLElement)` — наследуем контейнер, находим HTML-элементы и обрабатываем событие.

Его свойства:
`pprotected itemBasketIndex: HTMLElement` — индекс товара в корзине.
`protected deleteButton: HTMLButtonElement` — кнопка для удаления товара из корзины

Его методы:
`set index (value: string)` — отображает индекс товара в корзине.

#### События
События в моделях данных:
`productsData:changed` — сообщает, что наш массив всех товаров был изменен.
`productPreview:changed` — сообщает, что был выбран товар для подробного рассмотрения.
`basketData:changed` — сообщает, что наш массив товаров в корзине был изменен (добавление/удаление элемента).
`customerInfoData:changed` — сообщает, что данные о пользователи изменены (добавлены/удалены).

События в слое отображения:
`basketButton:open` — сообщает об нажатии кнопки для открытия модального окна корзины.
`modalWindowButton:close` – сообщает об нажатии кнопки для закрытия любого модального окна.
`orderButton:made` — сообщает об нажатии кнопки для оформления заказа из корзины.
`toNewPurchasesButton:go` — сообщает об нажатии кнопки для возвращения к главной странице.
`submitButton:submit` — сообщает об нажатии кнопки для подтверждения информации и перехода к сл странице.
`order:changed` — сообщает об изменении информации о данных заказа (оплата и адресс).
`contacts:changed` – сообщает об изменении информации о данных заказа (почта и телефон).
`itemToPreview:open` — сообщает об нажатии кнопки для открытия модального окна карточки товара.
`itemToBuy:pushed` — сообщает об нажатии кнопки для отправки товара в корзину.
`itemRemoveBasket:pushed` — сообщает об нажатии кнопки для удаления товара из корзины.

#### Презентер
Архитектура нашего приложения разработана в модели MVP, где разделяются слои данных и отображения, а их взаимодействие происходит через презентер. Презентер не хранит данные и не имеет доступа в разметку, а только отображает логику.

У нас одностраничное приложение, поэтому вся разработка презентера была описана в основном скрипте приложения main.ts.

Шаги для начала работы:
1. Создаём EventEmitter, модели данных и классы отображения.
2. Регистрируем подписки на события
3. Загружаем товары с сервера → кладём их в Products → модель эмитит productsData:changed → презентер рендерит Gallery.

Сценарии:

`Открытие превью товара`
1. Слушаем клик на CatalogCard c помощью "itemToPreview:open" и получаем id товара, на который клинули.
2. Презентер находит товар в продуктовой моделе с помощью id.
3. Если товар наден, то презентер сохраняет товар в продуктовой моделе для отображения его превью и это эмитит событие "productPreview:changed".
4. Презентер рендерит PreviewCard с данными выбранного товара, попутно проверяя можно ли купить выбранный товар. В зависимости от этого кнопка в PreviewCard будет иметь три варианта развития событий: добавление товара в корзину, удаление товара из корзины и отстуствие доступа к товару.
5. Презентер открывает модальное окно с контентом из PreviewCard.

`Добавление товара в корзину | Удаление товара из корзины`
1. Презентер с помощью модели данных корзины проверяет можно ли добавить в корзину выбранный товар. Если у выбранного товара price = null, то товар нельзя добавить в корзину и кнопка становится деактивированной. Если у выбранного товара price != null, то товар потенциально может быть добавлен в модель данных корзины, если в тот момент в ней не находится -> кнопка активна и принимает один из двух вариантов "Добавление товара в корзину | Удаление товара из корзины"
2. Отрисовываем PreviewCard с нужным значение кнопки.
3. Слушаем клик на PreviewCard с помощью "itemToBuy:pushed" и получаем id товара, на который клинули.
4. Презентер находит товар в продуктовой моделе с помощью id.
5. Если выбранного товара нет в моделе данных корзины, то его можно туда добавить –> у кнопки отрисовано значение 'В корзину' и добавляем выбранный товар в модель данных корзины. Если в моделе данных корзины уже есть выбранный товар, то добавить его еще раз нельзя, но можно удалить –> кнопка меняет свое значение на 'Удалить из корзины' и выбранный товар удаляется из модели данных корзины.
6. Действия, связанные в изменением товаров в моделе данных корзины, приводят к "basketData:changed".
7. Презентер обновляет данные для отображения корзины, основываясь на данных из модели данных корзины. Так же обновляются данные для счетчика в хэдере.

`Открытие корзины`
1. Слушаем клик в Header с помощью "basketButton:open".
2. Открываем модальное окно с данными для отображения корзины.
3. Если мы захотим удалить товар внутри корзины, то будем слушать клик на BasketCard с помощью "itemRemoveBasket:pushed", который даст нам id товара, который мы захотим удалить.
4. С помощью id презентер находит товар в моделе данных корзины. Если товар найдет, то происходит удаление и это приводит к "basketData:changed".
5. Обновление данных и перерисовка.

`Оформление заказа`
1. Презентер с помощью модели данных корзины проверяет есть ли товары в моделе данных корзины. Если товары есть, то заказ оформить можно и кнопка будет активна.
2. Собственно, слушаем клик в BasketView с помощью "orderButton:made".
3. Презентер создает форму для данных покупателя, сначала OrderForm с полями для адреса и выбора способа оплаты. Отрисосываем форму в модальном окне.
4. Любой ввод/выбор в форме приводит к "order:changed".
5. Передаем данные в модель данных покупателя, а это приводит к  "customerInfoData:changed".
6. В "customerInfoData:changed" мы вызываем функцию, которая проверяет валидность введенных/выбранных данных в нашей отрисованной в модальном окне на данный момент форме. Если что-то не так, то появляется сообщение о неправильно введенном поле.
7. Как только данные OrderForm будут введены правильно, то активируется кнопка SubmitButton.
8. Слушаем клик с помощью 'submitButton:submit' и определяем отрисованную в модальном окне на данный момент форму. Если это OrderForm, то снова проверяем валидность ее данных и если все ок, то переходим к созданию ContactsForm, а далее повторяем с ней все те же шаги, что и с OrderForm. Если же это клик был в ContactsForm, то переходим к отрисовке модального окна с подтвержением успешного заказа, который мы создаем с помощью функции buildSuccessedOrder.

`Подтверждение успешного заказа`
1. Слушаем клик с помощью 'submitButton:submit' и если он на форме ContactsForm, то проверяем валидность данных ContactsForm и переходим к отрисовке модального окна с подтвержением успешного заказа, который мы создаем с помощью функции buildSuccessedOrder.
2. Функция buildSuccessedOrder создает элемент для отображения успешного заказа. Туда презентер передает финальную стоимость заказа, полученную через модель данных корзины.
3. После отрисовки подтверждения успешного заказа мы можем увидеть сколько у нас списалось денег, а так же нажать кнопку для перехода к созданию нового заказа.
4. Слушаем клик с помощью "toNewPurchasesButton:go", который говорит презентеру закрыть модальное окно, а так же обнулить товары в моделе данных корзины (что приведет к "basketData:changed") и очистить данные в моделе данных покупателя (что приведет к "customerInfoData:changed). И далее будут происходить сценарии с этих событий.
